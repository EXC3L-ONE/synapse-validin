function getMetaSource() {
    [ meta:source=$lib.guid("validin", "ex", "powerup") :name="validin" ]
    return($node)
}

function getValidinAPIKey() {
    // see if the user has their own key set
    $apikey = $lib.user.vars.get("validin:apikey")
    if ($apikey) {
        return($apikey)
    }

    // no user key, check for global
    $apikey = $lib.globals.get("validin:apikey")
    if ($apikey) {
        return($apikey)
    }
 
    return($lib.false)
}

function setValidinAPIKey(key, self) {
    if ($self) {
        $lib.user.vars.set("validin:apikey", `Bearer {$key}`)
    } else {
        $lib.globals.set("validin:apikey", `Bearer {$key}`)
    }
    return($checkValidinAPIKey())
}

function checkValidinAPIKey() {
    $resp = $makeValidinAPIRequest("ping")
        
    if ($resp.status = "OK") {
        return($lib.true)
    } else {
        return($lib.false)
    }
}

function getTagPrefix() {
    return($lib.globals.get("ex.validin:tag-prefix", default=rep.validin))
}

function setTagPrefix(prefix) {
    ($ok, $norm) = $lib.trycast(syn:tag:part, $prefix)
    if (not $ok) {
        $lib.warn("failed to set tag prefix, invalid value: {s}", s=$prefix)
        return($lib.null)
    }

    $lib.globals.set("ex.validin:tag-prefix", $prefix)
}

function makeValidinAPIRequest(api_endpoint, method="GET") {
    $hostname = $getValidinHostname()
    $url = `https://{$hostname}/api/{$api_endpoint}`

    $headers = ({})
    $headers."Authorization" = $getValidinAPIKey()

    if ($method = "POST") {
        $resp = $lib.inet.http.post($url, headers=$headers)
    } else {
        $resp = $lib.inet.http.get($url, headers=$headers)
        //uncomment below for running testing
        //$resp = $lib.inet.http.get($url, headers=$headers, ssl_verify=$lib.false)
    }

    if ($resp.code != 200) { return($lib.null) }

    return($resp.body.json())
}


function parseDomainPDNS(data) {

    $srcnode = $getMetaSource()

    tee {
        for $dns_a in $data.records.A {
            $first_seen = $lib.time.fromunix($dns_a.first_seen)
            $last_seen = $lib.time.fromunix($dns_a.last_seen)
            [inet:dns:a=($dns_a.key, $dns_a.value) .seen=($first_seen, $last_seen)]
        }
    }
    {
        for $dns_ns in $data.records.NS {
            $first_seen = $lib.time.fromunix($dns_ns.first_seen)
            $last_seen = $lib.time.fromunix($dns_ns.last_seen)
            [inet:dns:ns=($dns_ns.key, $dns_ns.value) .seen=($first_seen, $last_seen)]
        }
    }
    {
        for $dns_aaaa in $data.records.AAAA {
            $first_seen = $lib.time.fromunix($dns_aaaa.first_seen)
            $last_seen = $lib.time.fromunix($dns_aaaa.last_seen)
            [inet:dns:aaaa=($dns_aaaa.key, $dns_aaaa.value) .seen=($first_seen, $last_seen)]
        }
    }
    | uniq |
    [<(seen)+ { yield $srcnode }]

}

function parseIpPDNS(data) {

    $srcnode = $getMetaSource()

    for $dns_a in $data.records.A {
        $first_seen = $lib.time.fromunix($dns_a.first_seen)
        $last_seen = $lib.time.fromunix($dns_a.last_seen)
        [inet:dns:a=($dns_a.value, $dns_a.key) .seen=($first_seen, $last_seen)]
    }

    [<(seen)+ { yield $srcnode }]
    | uniq

}

function getValidinHostname() {
    // see if the user has their own hostname set
    $hostname = $lib.user.vars.get("validin:hostname")
    if ($hostname) {
        return($hostname)
    }

    // no user hostname, check for global
    $hostname = $lib.globals.get("validin:hostname")
    if ($hostname) {
        return($hostname)
    }
 
    // Default to community hostname
    return("app.validin.com")
}

function setValidinHostname(hostname, self) {
    if ($self) {
        $lib.user.vars.set("validin:hostname", $hostname)
    } else {
        $lib.globals.set("validin:hostname", $hostname)
    }
}

function emitDomainRegHistory(data) {
    $srcnode = $getMetaSource()

    for $reg in $data.records.registration {
        $asof = $lib.time.parse($reg.date, "%Y-%m-%d")
        $created = $lib.time.parse($reg.registered.0, "%Y-%m-%dT%H:%M:%SZ")
        $expires = $lib.time.parse($reg.expires.0, "%Y-%m-%dT%H:%M:%SZ")
        $domain = $reg.domain
        $registrar = $reg.registrar.0

        // create init whois node
        [ inet:whois:rec=($domain, $asof)
            :created=$created
            :expires=$expires
            :registrar=$registrar
        ]

        // conditional on if updated field exists
        if $reg.updated {
            $updated = $lib.time.parse($reg.updated.0, "%Y-%m-%dT%H:%M:%SZ")
            [ :updated = $updated ] 
        }

        // Add nameserver relationships
        for $ns in $reg.nameservers {
            [ inet:whois:recns=($ns, $node) ]
        }
    }
    [<(seen)+ { yield $srcnode }]
    | uniq

}